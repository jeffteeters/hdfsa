Note: Oct 16, 2022.
THIS IS OUTDATTED!  IT'S FOR THE ORIGIONAL VERSION OF
THE PAPER SUBMITTED IN FEB 2022.

To generate the new figures, run script
plot_eedb.py to generate figures that are saved
in directory
frontiers_v2_figures
for figures for the new version of the paper (v2)
which will be published in Dec 2022.

----


This file has instuctions for generating the figures with
graphs in the in the 2022 Frontiers paper:

On separating long- and short-term memories in hyperdimensional computing
Jeff Teeters âˆ—, Denis Kleyko, Pentti Kanerva and Bruno Olshausen


**************************************************
Figure 2. Recall error vs storage size (in bytes).
**************************************************

The raw data for this figure is in file:
sdata_9.txt
It was generated by running program "hdfsa.py".
At the top of the file (sdata_9.txt) is given the command
arguments used to run hdfsa.py to generate the file.  The
command is: 

python hdfsa.py -s 100 -r 10 -c 10 -w 512 -t 3 -g 1

(All command line options can be viewed via running:
python hdfsa.py -h).

Note: The output file will have a name like
"sdata*.txt", where the "*" will change (e.g. "_1", "_2", ...)
if previous files where generated.  "sdata_9.txt" just happend
to be the name generated for the file used in the figure
in the paper.

Once the raw data file (name like: sdata_9.txt) is generated as
described above, the plots in Figure 2 are created by running
program "plot_sinfo.py".  The commands are:

python plot_sinfo.py <path_to_directory>/sdata_9.txt linear
python plot_sinfo.py <path_to_directory>/sdata_9.txt log

where "<path_to_directory>" is the path to the directory
containing file "sdata_9.txt" (or whatever the name like
"sdata*.txt" is).

The first command generated the linear plot, the second the
log plot.  Both commands generate more than one plot, only the
first is included in the paper.

*********************************************************************
** Figure 3. Recall error vs percent bits (or memory counters) flips.
*********************************************************************

Graphs for this figure are generated similar to how Figure 2 was
generated.  First, program hdfsa.py is run to generate the raw data.
The command-line parameters used are given at the top of file
"fdata_9.txt"  (Note the name starts with "f" -for bit flips, not
"s" - which stands for size).  The command is:
python hdfsa.py -s 100 -a 10 -c 10 -w 512 -m 1724 -a 11 -b 72072 -j 1 -f 1 -t 3 -e 6872

This generates an output file, with name like: "fdata*.txt", where the
"*" depends on what other files are present with the same pattern, as
above ("*" is like "_1", "_2", ...).  The different file names are
generated so files are not overwritten.

Once the raw data file is generated, the plots are generated by running
the "plot_sinfo.py" program (same program used for the "Recall error vs.
storage size" plot).  The commands are:

python plot_sinfo.py <path_to_directory>/fdata_9.txt linear
python plot_sinfo.py <path_to_directory>/fdata_9.txt log

where "<path_to_directory>" is the path to the directory
containing file "fdata_9.txt" (or whatever the name like
"fdata*.txt" is).

************************************************************************
** Figure 4. Ratio of number of computations required to recall a vector
************************************************************************

 This is generated by running:

 python bundle_vs_sdm_efficiency.py cal linear

 The second plot generated is the one in the paper.

****************************************************************
** Figure 5. Histogram of counter sums in SDM of different sizes
****************************************************************

 These are generated by running "hdfsa.py" with the following parameters:

 python hdfsa.py -s 100 -r 10 -c 10 -w 512 -t 1 -g 1 -u 1

 The histograms are generated for each size.  Only the first and last are
 included in the paper.  The output file "sdm_counter_usage.txt" has
 the mean and standard deviation of each histogram.


*********************************************************************
** Figure 6. Memory efficiency for a superposition vector (B) and SDM
*********************************************************************

 This is generated by running:

 python bundle_vs_sdm_efficiency.py mem linear





